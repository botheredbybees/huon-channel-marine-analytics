# Update metadata Table: Add AODN UUID Field (Non-PostGIS Version)

## Overview

Add an optional `aodn_uuid` field to the `metadata` table to track the source AODN UUID separately from the internal `uuid` field. This supports your future requirement to ingest non-AODN datasets while maintaining AODN data provenance.

**Key Design Decision**: The internal `uuid` field remains the primary key (links all related data), while `aodn_uuid` is optional and tracks the original AODN source identifier.

---

## 1. SQL Changes for `init.sql`

### Add Column to Metadata Table

Add this to the `metadata` table definition in `init.sql` (after the `date_created` column):

```sql
CREATE TABLE IF NOT EXISTS metadata (
  id SERIAL PRIMARY KEY,
  uuid TEXT UNIQUE NOT NULL,
  aodn_uuid TEXT UNIQUE,  -- ✓ NEW: AODN source identifier (optional, nullable)
  parent_uuid TEXT,
  title TEXT NOT NULL,
  abstract TEXT,
  credit TEXT,
  status TEXT,
  topic_category TEXT,
  metadata_creation_date TIMESTAMP,
  metadata_revision_date TIMESTAMP,
  citation_date TIMESTAMP,
  language TEXT DEFAULT 'eng',
  character_set TEXT DEFAULT 'utf8',
  west DECIMAL(10,6),
  east DECIMAL(10,6),
  south DECIMAL(10,6),
  north DECIMAL(10,6),
  time_start DATE,
  time_end DATE,
  vertical_min DECIMAL(6,2),
  vertical_max DECIMAL(6,2),
  vertical_crs TEXT,
  lineage TEXT,
  supplemental_info TEXT,
  use_limitation TEXT,
  license_url TEXT,
  distribution_wfs_url TEXT,
  distribution_wms_url TEXT,
  distribution_portal_url TEXT,
  distribution_publication_url TEXT,
  dataset_name TEXT,
  dataset_path TEXT,
  extracted_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  date_created DATE
);
```

### Add Index for AODN UUID Lookups

Add this index definition after the metadata indexes:

```sql
-- Index for AODN UUID lookups (sparse - only non-null values)
CREATE INDEX IF NOT EXISTS idx_metadata_aodn_uuid ON metadata(aodn_uuid)
  WHERE aodn_uuid IS NOT NULL;
```

### Migration Script (for existing databases)

If you already have a `metadata` table, run this migration:

```sql
-- Add the column if it doesn't exist
ALTER TABLE metadata 
  ADD COLUMN aodn_uuid TEXT UNIQUE 
  DEFAULT NULL;

-- Add the index
CREATE INDEX IF NOT EXISTS idx_metadata_aodn_uuid ON metadata(aodn_uuid)
  WHERE aodn_uuid IS NOT NULL;

-- Verify the column was added
SELECT column_name, data_type, is_nullable 
FROM information_schema.columns 
WHERE table_name = 'metadata' 
  AND column_name = 'aodn_uuid';
```

---

## 2. Update `docs/database_schema.md`

### Replace the metadata section with this updated version:

#### OLD (Delete this section):
```markdown
### `metadata`
The central table for all datasets. Every file or distinct dataset ingested has an entry here.

#### DDL

```sql
CREATE TABLE metadata (
    id SERIAL PRIMARY KEY,
    uuid TEXT UNIQUE NOT NULL,
    parent_uuid TEXT,
    ...
    extent_geom GEOMETRY(POLYGON, 4326),
    bbox_envelope BOX2D GENERATED ALWAYS AS (BOX2D(extent_geom)) STORED
);
```
```

#### NEW (Replace with):
```markdown
### `metadata`
The central registry for all datasets (AODN and future non-AODN sources).

#### DDL

```sql
CREATE TABLE metadata (
    id SERIAL PRIMARY KEY,
    uuid TEXT UNIQUE NOT NULL,
    aodn_uuid TEXT UNIQUE,
    parent_uuid TEXT,
    title TEXT NOT NULL,
    abstract TEXT,
    credit TEXT,
    status TEXT,
    topic_category TEXT,
    metadata_creation_date TIMESTAMP,
    metadata_revision_date TIMESTAMP,
    citation_date TIMESTAMP,
    language TEXT DEFAULT 'eng',
    character_set TEXT DEFAULT 'utf8',
    west DECIMAL(10,6),
    east DECIMAL(10,6),
    south DECIMAL(10,6),
    north DECIMAL(10,6),
    time_start DATE,
    time_end DATE,
    vertical_min DECIMAL(6,2),
    vertical_max DECIMAL(6,2),
    vertical_crs TEXT,
    lineage TEXT,
    supplemental_info TEXT,
    use_limitation TEXT,
    license_url TEXT,
    distribution_wfs_url TEXT,
    distribution_wms_url TEXT,
    distribution_portal_url TEXT,
    distribution_publication_url TEXT,
    dataset_name TEXT,
    dataset_path TEXT,
    extracted_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    date_created DATE
);

CREATE INDEX idx_metadata_uuid ON metadata(uuid);
CREATE INDEX idx_metadata_aodn_uuid ON metadata(aodn_uuid) WHERE aodn_uuid IS NOT NULL;
CREATE INDEX idx_metadata_bbox ON metadata(west, east, south, north);
CREATE INDEX idx_metadata_time ON metadata(time_start, time_end);
```

#### Key Fields

- **`id`** (PK): Internal integer ID used for all foreign keys (performance).
- **`uuid`**: Unique internal identifier. Used to link all related data (measurements, parameters, species observations). Generated by the system on insert.
- **`aodn_uuid`** ⭐ **[NEW]**: The AODN/IMOS UUID from the original ISO 19115 XML metadata. **Optional** (nullable) to support future non-AODN datasets. Allows tracking data provenance back to AODN source.
  - Always populated when ingesting from AODN sources
  - NULL for non-AODN datasets
  - Has unique constraint to prevent duplicate AODN ingests
  - Sparse index (only non-null values) for efficient queries
- **`west`, `east`, `south`, `north`**: Bounding box coordinates in decimal degrees (WGS84 / EPSG:4326). Pure PostgreSQL, no PostGIS required.
- **`dataset_path`**: Relative path to the source folder/file on disk.
- **`dataset_name`**: Human-readable name of the dataset (e.g., "Australian Chlorophyll-a Database").

#### Relationships

| Field | Links To | Purpose |
|-------|----------|---------|
| `id` | FK in `parameters`, `measurements`, `species_observations` | Primary relationships |
| `uuid` | FK in `measurements.uuid`, `parameters.uuid` | Backward reference field |
| `aodn_uuid` | AODN catalog | Provenance tracking |

#### Usage Examples

```sql
-- Find dataset by AODN UUID
SELECT * FROM metadata WHERE aodn_uuid = '9eff1f00-5115-4726-b41f-5a1a93f97575';

-- Check if AODN dataset already ingested (deduplication)
SELECT id, dataset_name FROM metadata 
WHERE aodn_uuid = %s;

-- List all AODN datasets (non-null aodn_uuid)
SELECT id, dataset_name, aodn_uuid 
FROM metadata 
WHERE aodn_uuid IS NOT NULL 
ORDER BY dataset_name;

-- List all non-AODN datasets
SELECT id, dataset_name, uuid 
FROM metadata 
WHERE aodn_uuid IS NULL 
ORDER BY dataset_name;

-- Join measurements with AODN provenance info
SELECT 
  m.time, m.value, m.parameter_code,
  md.dataset_name, md.aodn_uuid, md.lineage
FROM measurements m
JOIN metadata md ON m.metadata_id = md.id
WHERE md.aodn_uuid IS NOT NULL;
```
```

---

## 3. Update Population Scripts

### Modify `enrich_metadata_from_xml.py`

Update the XML parsing to extract AODN UUID and populate `aodn_uuid`:

```python
import xml.etree.ElementTree as ET
import psycopg2
import os

def extract_aodn_uuid_from_xml(xml_path):
    """Extract AODN UUID from ISO 19115 XML metadata"""
    try:
        tree = ET.parse(xml_path)
        root = tree.getroot()
        
        # Common namespace prefixes in AODN metadata
        namespaces = {
            'gmd': 'http://www.opengis.net/gmd',
            'gco': 'http://www.opengis.net/gco',
            'mcp': 'http://schemas.aodn.org.au/mcp',
        }
        
        # Try different XPath patterns
        uuid_elem = root.find('.//gmd:uuid/gco:CharacterString', namespaces)
        if uuid_elem is None:
            uuid_elem = root.find('.//gmd:fileIdentifier/gco:CharacterString', namespaces)
        
        if uuid_elem is not None and uuid_elem.text:
            return uuid_elem.text.strip()
    except Exception as e:
        logger.warning(f"Could not extract UUID from {xml_path}: {e}")
    
    return None

def insert_metadata_with_aodn_uuid(cursor, metadata_dict, aodn_uuid=None):
    """Insert metadata record with optional AODN UUID"""
    
    query = """
    INSERT INTO metadata (
        uuid, aodn_uuid, title, abstract, west, east, south, north,
        time_start, time_end, dataset_name, dataset_path, extracted_at
    ) VALUES (
        %s, %s, %s, %s, %s, %s, %s, %s,
        %s, %s, %s, %s, NOW()
    )
    ON CONFLICT (uuid) DO UPDATE SET
        aodn_uuid = EXCLUDED.aodn_uuid,
        extracted_at = NOW()
    RETURNING id;
    """
    
    params = (
        metadata_dict['uuid'],
        aodn_uuid,  # ← NEW: Add AODN UUID
        metadata_dict.get('title'),
        metadata_dict.get('abstract'),
        metadata_dict.get('west'),
        metadata_dict.get('east'),
        metadata_dict.get('south'),
        metadata_dict.get('north'),
        metadata_dict.get('time_start'),
        metadata_dict.get('time_end'),
        metadata_dict.get('dataset_name'),
        metadata_dict.get('dataset_path'),
    )
    
    cursor.execute(query, params)
    return cursor.fetchone()[0]
```

### Deduplication Check (Before Ingestion)

Add this check to prevent re-ingesting the same AODN dataset:

```python
def check_aodn_dataset_exists(cursor, aodn_uuid):
    """Check if this AODN dataset has already been ingested"""
    if not aodn_uuid:
        return False  # Non-AODN datasets can be re-ingested with different internal UUIDs
    
    cursor.execute(
        "SELECT id, dataset_name FROM metadata WHERE aodn_uuid = %s",
        (aodn_uuid,)
    )
    result = cursor.fetchone()
    
    if result:
        logger.warning(f"AODN dataset {aodn_uuid} already exists as {result[1]} (id={result[0]})")
        return True
    
    return False

# In main ETL loop:
for xml_file in xml_files:
    aodn_uuid = extract_aodn_uuid_from_xml(xml_file)
    
    if check_aodn_dataset_exists(cursor, aodn_uuid):
        logger.info(f"Skipping duplicate AODN dataset: {aodn_uuid}")
        continue
    
    # Proceed with insertion
    metadata_id = insert_metadata_with_aodn_uuid(cursor, metadata_dict, aodn_uuid)
    logger.info(f"Inserted: {metadata_dict.get('dataset_name')} (AODN: {aodn_uuid})")
```

---

## 4. Updated Schema Diagram

```mermaid
erDiagram
    METADATA ||--o{ MEASUREMENTS : contains
    METADATA ||--o{ PARAMETERS : defines
    METADATA ||--o{ SPECIES_OBSERVATIONS : contains
    
    MEASUREMENTS {
        timestamp time
        string parameter_code
        double value
        string namespace
        integer metadata_id FK
        string uuid FK
    }
    
    METADATA {
        integer id PK
        string uuid UNIQUE "internal identifier"
        string aodn_uuid UNIQUE "AODN source (optional)"
        string dataset_name
        decimal west "bbox west"
        decimal east "bbox east"
        decimal south "bbox south"
        decimal north "bbox north"
    }
    
    PARAMETERS {
        integer id PK
        integer metadata_id FK
        string uuid FK
        string parameter_code
    }
```

---

## 5. Implementation Checklist

- [ ] **Step 1**: Update `init.sql` with the new `aodn_uuid` column and index
- [ ] **Step 2**: Update `docs/database_schema.md` with the new field documentation
- [ ] **Step 3**: Update `enrich_metadata_from_xml.py` to extract and populate `aodn_uuid`
- [ ] **Step 4**: Add deduplication logic to prevent re-ingesting AODN datasets
- [ ] **Step 5**: Test migration on a backup database
- [ ] **Step 6**: Run migration on production database (if existing metadata table)
- [ ] **Step 7**: Test ETL scripts with new field
- [ ] **Step 8**: Verify no duplicate AODN UUIDs exist in production

---

## 6. Query Examples

### Check AODN UUID Coverage

```sql
-- How many datasets have AODN UUIDs?
SELECT 
  COUNT(*) AS total,
  COUNT(aodn_uuid) AS aodn_sources,
  COUNT(*) - COUNT(aodn_uuid) AS non_aodn
FROM metadata;

-- Result:
-- total | aodn_sources | non_aodn
-- ------|--------------|----------
--    38 |           38 |        0  (currently all AODN)
```

### Find Datasets by AODN Source

```sql
-- Get a specific AODN dataset by its original UUID
SELECT id, uuid, dataset_name, title 
FROM metadata 
WHERE aodn_uuid = '9eff1f00-5115-4726-b41f-5a1a93f97575';
```

### Check for Duplicate AODN Ingests

```sql
-- This should return 0 rows if no duplicates exist
SELECT aodn_uuid, COUNT(*) as count 
FROM metadata 
WHERE aodn_uuid IS NOT NULL 
GROUP BY aodn_uuid 
HAVING COUNT(*) > 1;
```

---

## 7. Backward Compatibility

✓ **Non-breaking change**: Existing code continues to work
- `uuid` field unchanged (primary key)
- `aodn_uuid` is nullable and optional
- No existing queries need modification
- All foreign keys still reference `uuid` and `id`

---

## 8. Future Non-AODN Dataset Integration

When you later ingest non-AODN data:

```python
# For non-AODN datasets, aodn_uuid will be NULL
metadata_id = insert_metadata_with_aodn_uuid(
    cursor,
    metadata_dict={
        'uuid': generate_new_uuid(),  # Generate new internal UUID
        'dataset_name': 'My Custom Dataset',
        'title': 'Custom observation data',
        # ... other fields
    },
    aodn_uuid=None  # ← NULL for non-AODN
)

# The internal `uuid` links all data relationships
# aodn_uuid remains NULL
```

---

## Summary of Changes

| File | Change | Impact |
|------|--------|--------|
| `init.sql` | Add `aodn_uuid` column + sparse index | Schema update |
| `docs/database_schema.md` | Document `aodn_uuid` field | Documentation |
| `enrich_metadata_from_xml.py` | Extract and populate `aodn_uuid` | Data population |
| Existing code | No changes needed | Fully backward compatible |

